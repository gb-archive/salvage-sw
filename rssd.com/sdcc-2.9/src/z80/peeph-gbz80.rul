/* Generated file, DO NOT Edit!  */
/* To Make changes to rules edit */
/* <port>/peeph.def instead.     */
"\n"
"\n"
"replace restart {\n"
"	ld	%1,%1\n"
"} by {\n"
"	; peephole 1 removed redundant load.\n"
"} if notVolatile(%1)\n"
"\n"
"replace restart {\n"
"	jp	NC,%1\n"
"	jp	%2\n"
"%1:\n"
"} by {\n"
"	jp	C,%2\n"
"	; peephole 3 removed jp by using inverse jump logic\n"
"%1:\n"
"} if labelRefCountChange(%1 -1)\n"
"\n"
"replace restart {\n"
"	jp	C,%1\n"
"	jp	%2\n"
"%1:\n"
"} by {\n"
"	jp	NC,%2\n"
"	; peephole 4 removed jp by using inverse jump logic\n"
"%1:\n"
"} if labelRefCountChange(%1 -1)\n"
"\n"
"replace restart {\n"
"	jp	NZ,%1\n"
"	jp	%2\n"
"%1:\n"
"} by {\n"
"	jp	Z,%2\n"
"	; peephole 5 removed jp by using inverse jump logic\n"
"%1:\n"
"} if labelRefCountChange(%1 -1)\n"
"\n"
"replace restart {\n"
"	jp	Z,%1\n"
"	jp	%2\n"
"%1:\n"
"} by {\n"
"	jp	NZ,%2\n"
"	; peephole 6 removed jp by using inverse jump logic\n"
"%1:\n"
"} if labelRefCountChange(%1 -1)\n"
"\n"
"replace restart {\n"
"	jp	%5\n"
"} by {\n"
"	jp	%6\n"
"	; peephole 7 redirected jump-to-jump at %5 by jump to %6\n"
"} if labelIsUncondJump(), labelRefCountChange(%5 -1), labelRefCountChange(%6 +1)\n"
"\n"
"replace restart {\n"
"	jp	%1,%5\n"
"} by {\n"
"	jp	%1,%6\n"
"	; peephole 8 redirected jump-to-jump at %5 by jump to %6\n"
"} if labelIsUncondJump(), labelRefCountChange(%5 -1), labelRefCountChange(%6 +1)\n"
"\n"
"replace restart {\n"
"	ld	%2,%3\n"
"	jp	%4\n"
"%5:\n"
"	ld	%2,%3\n"
"%4:\n"
"} by {\n"
"	; peephole 9 removed jump and redundant load.\n"
"%5:\n"
"	ld	%2,%3\n"
"%4:\n"
"} if labelRefCountChange(%4 -1)\n"
"\n"
"replace restart {\n"
"	xor	a,a\n"
"	ld	a,#0x00\n"
"} by {\n"
"	xor	a,a\n"
"	; peephole 10 removed redundant load of 0 into a.\n"
"}\n"
"\n"
"replace {\n"
"	ld	e,#0x%1\n"
"	ld	d,#0x%2\n"
"} by {\n"
"	ld	de,#0x%2%1\n"
"	; peephole 11 combined constant loads into register pair.\n"
"}\n"
"\n"
"replace {\n"
"	ld	l,#0x%1\n"
"	ld	h,#0x%2\n"
"} by {\n"
"	ld	hl,#0x%2%1\n"
"	; peephole 12 combined constant loads into register pair.\n"
"}\n"
"\n"
"replace {\n"
"	ld	c,#0x%1\n"
"	ld	b,#0x%2\n"
"} by {\n"
"	ld	bc,#0x%2%1\n"
"	; peephole 13 combined constant loads into register pair.\n"
"}\n"
"\n"
"replace restart {\n"
"	ld	%1,a\n"
"	ld	a,%1\n"
"} by {\n"
"	ld	%1,a\n"
"	; peephole 14 removed redundant load from %1 into a.\n"
"} if notVolatile(%1)\n"
"\n"
"replace restart {\n"
"	ld	a,%1\n"
"	ld	%1,a\n"
"} by {\n"
"	ld	a,%1\n"
"	; peephole 15 removed redundant load from a into %1.\n"
"} if notVolatile(%1)\n"
"\n"
"replace restart {\n"
"	ld	%2,%3\n"
"	ld	a,%2\n"
"	and	a,%1\n"
"	ld	%2,%4\n"
"} by {\n"
"	ld	a,%3\n"
"	; peephole 16 moved %3 directly into a instead of going through %2.\n"
"	and	a,%1\n"
"	ld	%2,%4\n"
"} if notVolatile(%2), operandsNotSame\n"
"\n"
"replace restart {\n"
"	ld	%1,a\n"
"	ld	a,%2\n"
"	or	a,%1\n"
"} by {\n"
"	ld	%1,a\n"
"	or	a,%2\n"
"	; peephole 17 removed load by reordering or arguments.\n"
"} if notVolatile(%1)\n"
"\n"
"replace restart {\n"
"	ld	%1,a\n"
"	xor	a,a\n"
"	or	a,%1\n"
"} by {\n"
"	ld	%1,a\n"
"	or	a,a\n"
"	; peephole 18 used value still in a instead of loading it from %1.\n"
"}\n"
"\n"
"replace restart {\n"
"	or	a,%1\n"
"	or	a,a\n"
"} by {\n"
"	or	a,%1\n"
"	; peephole 19 removed redundant or after or.\n"
"}\n"
"\n"
"replace restart {\n"
"	and	a,%1\n"
"	or	a,a\n"
"} by {\n"
"	and	a,%1\n"
"	; peephole 20 removed redundant or after and.\n"
"}\n"
"\n"
"replace restart {\n"
"	xor	a,%1\n"
"	or	a,a\n"
"} by {\n"
"	xor	a,%1\n"
"	; peephole 21 removed redundant or after xor.\n"
"}\n"
"\n"
"replace restart {\n"
"	ld	%1,a\n"
"	and	a,%2\n"
"	ld	%1,a\n"
"} by {\n"
"	; peephole 22 removed redundant load into %1.\n"
"	and	a,%2\n"
"	ld	%1,a\n"
"} if notVolatile(%1)\n"
"\n"
"replace {\n"
"	ld	%1,%2\n"
"	ld	a,%2\n"
"} by {\n"
"	ld	a,%2\n"
"	ld	%1,a\n"
"	; peephole 23 load value in a first and use it next\n"
"} if notVolatile(%1 %2)\n"
"\n"
"replace restart {\n"
"	ld	%1,%2\n"
"	ld	%3,%4\n"
"	ld	%2,%1\n"
"	ld	%4,%3\n"
"} by {\n"
"	ld	%1,%2\n"
"	ld	%3,%4\n"
"	; peephole 24 removed redundant load from %3%1 into %4%2\n"
"} if notVolatile(%1 %2 %3 %4)\n"
"\n"
"replace restart {\n"
"	ld	b,%1\n"
"	ld	a,b\n"
"	pop	bc\n"
"} by {\n"
"	ld	a,%1\n"
"	; peephole 25 removed load into b\n"
"	pop	bc\n"
"}\n"
"\n"
"replace restart {\n"
"	ld	c,%1\n"
"	ld	a,c\n"
"	pop	bc\n"
"} by {\n"
"	ld	a,%1\n"
"	; peephole 26 removed load into c\n"
"	pop	bc\n"
"}\n"
"\n"
"replace restart {\n"
"	ld	d,%1\n"
"	ld	a,d\n"
"	pop	de\n"
"} by {\n"
"	ld	a,%1\n"
"	; peephole 27 removed load into d\n"
"	pop	de\n"
"}\n"
"\n"
"replace restart {\n"
"	ld	e,%1\n"
"	ld	a,e\n"
"	pop	de\n"
"} by {\n"
"	ld	a,%1\n"
"	; peephole 28 removed load into e\n"
"	pop	de\n"
"}\n"
"\n"
"replace restart {\n"
"	ld	h,%1\n"
"	ld	a,h\n"
"	pop	hl\n"
"} by {\n"
"	ld	a,%1\n"
"	; peephole 29 removed load into h\n"
"	pop	hl\n"
"}\n"
"\n"
"replace restart {\n"
"	ld	l,%1\n"
"	ld	a,l\n"
"	pop	hl\n"
"} by {\n"
"	ld	a,%1\n"
"	; peephole 30 removed load into l\n"
"	pop	hl\n"
"}\n"
"\n"
"replace restart {\n"
"	ld	a,c\n"
"	push	af\n"
"	inc	sp\n"
"	ld	a,#%2\n"
"	push	af\n"
"	inc	sp\n"
"	call	%3\n"
"} by {\n"
"	ld	b,c\n"
"	ld	c,#%2\n"
"	push	bc\n"
"	; peephole 31 moved and pushed arguments c and #%2 through bc instead of pushing them individually.\n"
"	call	%3\n"
"}\n"
"\n"
"replace restart {\n"
"	ld	a,e\n"
"	push	af\n"
"	inc	sp\n"
"	ld	a,#%2\n"
"	push	af\n"
"	inc	sp\n"
"	call	%3\n"
"} by {\n"
"	ld	d,e\n"
"	ld	e,#%2\n"
"	push	de\n"
"	; peephole 32 moved and pushed arguments e and #%2 through de instead of pushing them individually.\n"
"	call	%3\n"
"}\n"
"\n"
"replace restart {\n"
"	ld	a,%1\n"
"	sub	a,%2\n"
"	jp	%3,%4\n"
"	ld	a,%1\n"
"} by {\n"
"	ld	a,%1\n"
"	cp	a,%2\n"
"	jp	%3,%4\n"
"	; peephole 33 removed load by replacing sub with cp\n"
"	assert	a=%1\n"
"} if notVolatile(%1)\n"
"\n"
"replace restart {\n"
"	assert	a=%1\n"
"	sub	a,%2\n"
"	jp	%3,%4\n"
"	ld	a,%1\n"
"} by {\n"
"	cp	a,#%2\n"
"	jp	%3,%4\n"
"	; peephole 34 removed load by replacing sub with cp\n"
"	assert	a=%1\n"
"}\n"
"\n"
"replace restart {\n"
"	assert	a=%1\n"
"} by {\n"
"}\n"
"\n"
"replace restart {\n"
"	sub	a,#0xFF\n"
"	jp	Z,%1\n"
"} by {\n"
"	inc	a\n"
"	; peephole 35 replaced sub a,#0xFF by inc a.\n"
"	jp	Z,%1\n"
"}\n"
"\n"
"replace restart {\n"
"	sub	a,#0xFF\n"
"	jp	NZ,%1\n"
"} by {\n"
"	inc	a\n"
"	; peephole 36 replaced sub a,#0xFF by inc a.\n"
"	jp	NZ,%1\n"
"}\n"
"\n"
"replace restart {\n"
"	ld	bc,#%1 + %2\n"
"	ld	a,c\n"
"	add	a,%3\n"
"	ld	c,a\n"
"	ld	a,b\n"
"	adc	a,%4\n"
"	ld	b,a\n"
"} by {\n"
"	ld	a,#<(%1 + %2)\n"
"	add	a,%3\n"
"	ld	c,a\n"
"	ld	a,#>(%1 + %2)\n"
"	; peephole 37 directly used (%1 + %2) in calculation instead of placing it in bc first.\n"
"	adc	a,%4\n"
"	ld	b,a\n"
"}\n"
"\n"
"replace restart {\n"
"	ld	de,#%1 + %2\n"
"	ld	a,e\n"
"	add	a,%3\n"
"	ld	e,a\n"
"	ld	a,d\n"
"	adc	a,%4\n"
"	ld	d,a\n"
"} by {\n"
"	ld	a,#<(%1 + %2)\n"
"	add	a,%3\n"
"	ld	e,a\n"
"	ld	a,#>(%1 + %2)\n"
"	; peephole 38 directly used (%1 + %2) in calculation instead of placing it in de first.\n"
"	adc	a,%4\n"
"	ld	d,a\n"
"}\n"
"\n"
"replace restart {\n"
"	rlca\n"
"	ld	a,#0x00\n"
"	rla\n"
"} by {\n"
"	rlca\n"
"	and	a,#0x01\n"
"	; peephole 39 replaced zero load, rla by and since rlca writes the same value to carry bit and least significant bit.\n"
"}\n"
"\n"
"replace restart {\n"
"	ld	%1,%2\n"
"	push	%1\n"
"	pop	%4\n"
"	ld	%1,%3\n"
"} by {\n"
"	ld	%4,%2\n"
"	; peephole 40 moved %2 directly into de instead of going through %1.\n"
"	ld	%1,%3\n"
"}\n"
"\n"
"replace restart {\n"
"	add	a,#0x00\n"
"	ld	%2,a\n"
"	ld	a,%3\n"
"	adc	a,%4\n"
"} by {\n"
"	; peephole 41 removed lower part of multibyte addition.\n"
"	ld	%2,a\n"
"	ld	a,%3\n"
"	add	a,%4\n"
"}\n"
"\n"
"replace restart {\n"
"	ld	%1,a\n"
"	ld	a,%2\n"
"	add	a,%1\n"
"	ld	%1,a\n"
"} by {\n"
"	; peephole 42 removed loads by exploiting commutativity of addition.\n"
"	add	a,%2\n"
"	ld	%1,a\n"
"} if notVolatile(%1)\n"
"\n"
"replace restart {\n"
"	ld	%1, a\n"
"	sla	%1\n"
"	ld	a, %2\n"
"	//add	%3, %4\n"
"} by {\n"
"	add	a, a\n"
"	; peephole 42a shifts in accumulator insted of %1\n"
"	ld	%1, a\n"
"	ld	a, %2\n"
"	//add	%3, %4\n"
"}\n"
"\n"
"replace restart {\n"
"	ld	%1,a\n"
"	ld	a,%2\n"
"	add	a,%1\n"
"} by {\n"
"	ld	%1, a\n"
"	; peephole 43 removed load by exploiting commutativity of addition.\n"
"	add	a,%2\n"
"}\n"
"\n"
"replace restart {\n"
"	or	a,%1\n"
"	jp	NZ,%2\n"
"	xor	a,a\n"
"	or	a,%3\n"
"} by {\n"
"	or	a,%1\n"
"	jp	NZ,%2\n"
"	; peephole 44 removed redundant zeroing of a (which has just been tested to be #0x00).\n"
"	or	a,%3\n"
"}\n"
"\n"
"replace restart {\n"
"	or	a,%1\n"
"	jp	NZ,%2\n"
"	ld	%3,#0x00\n"
"} by {\n"
"	or	a,%1\n"
"	jp	NZ,%2\n"
"	ld	%3,a\n"
"	; peephole 45 replaced constant #0x00 by a (which has just been tested to be #0x00).\n"
"}\n"
"\n"
"replace restart {\n"
"	and	a,%1\n"
"	jp	NZ,%2\n"
"	ld	%3,#0x00\n"
"} by {\n"
"	and	a,%1\n"
"	jp	NZ,%2\n"
"	ld	%3,a\n"
"	; peephole 46 replaced constant #0x00 by a (which has just been tested to be #0x00).\n"
"}\n"
"\n"
"replace restart {\n"
"	sub	a,%1\n"
"	jp	NZ,%2\n"
"	ld	%3,#0x00\n"
"} by {\n"
"	sub	a,%1\n"
"	jp	NZ,%2\n"
"	ld	%3,a\n"
"	; peephole 47 replaced constant #0x00 by a (which has just been tested to be #0x00).\n"
"}\n"
"\n"
"replace restart {\n"
"	dec	a\n"
"	jp	NZ,%1\n"
"	ld	%2,#0x00\n"
"} by {\n"
"	dec	a\n"
"	jp	NZ,%1\n"
"	ld	%2,a\n"
"	; peephole 48 replaced constant #0x00 by a (which has just been tested to be #0x00).\n"
"}\n"
"\n"
"replace restart {\n"
"	or	a,%1\n"
"	jp	NZ,%2\n"
"	ld	a,%3\n"
"	or	a,a\n"
"} by {\n"
"	or	a,%1\n"
"	jp	NZ,%2\n"
"	or	a,%3\n"
"	; peephole 49 shortened or using a (which has just been tested to be #0x00).\n"
"}\n"
"\n"
"replace restart {\n"
"	and	a,%1\n"
"	jp	NZ,%2\n"
"	ld	a,%3\n"
"	or	a,a\n"
"} by {\n"
"	and	a,%1\n"
"	jp	NZ,%2\n"
"	or	a,%3\n"
"	; peephole 50 shortened or using a (which has just been tested to be #0x00).\n"
"}\n"
"\n"
"replace restart {\n"
"	sub	a,%1\n"
"	jp	NZ,%2\n"
"	ld	a,%3\n"
"	or	a,a\n"
"} by {\n"
"	sub	a,%1\n"
"	jp	NZ,%2\n"
"	or	a,%3\n"
"	; peephole 51 shortened or using a (which has just been tested to be #0x00).\n"
"}\n"
"\n"
"replace restart {\n"
"	dec	a\n"
"	jp	NZ,%1\n"
"	ld	a,%2\n"
"	or	a,a\n"
"} by {\n"
"	dec	a\n"
"	jp	NZ,%1\n"
"	or	a,%2\n"
"	; peephole 52 shortened or using a (which has just been tested to be #0x00).\n"
"}\n"
"\n"
"replace restart {\n"
"	or	a,%1\n"
"	jp	NZ,%2\n"
"	push	%3\n"
"	ld	%4,#0x00\n"
"} by {\n"
"	or	a,%1\n"
"	jp	NZ,%2\n"
"	push	%3\n"
"	ld	%4,a\n"
"	; peephole 53 replaced constant #0x00 by a (which has just been tested to be #0x00).\n"
"}\n"
"\n"
"replace restart {\n"
"	and	a,%1\n"
"	jp	NZ,%2\n"
"	push	%3\n"
"	ld	%4,#0x00\n"
"} by {\n"
"	sub	a,%1\n"
"	jp	NZ,%2\n"
"	push	%3\n"
"	ld	%4,a\n"
"	; peephole 54 replaced constant #0x00 by a (which has just been tested to be #0x00).\n"
"}\n"
"\n"
"replace restart {\n"
"	sub	a,%1\n"
"	jp	NZ,%2\n"
"	push	%3\n"
"	ld	%4,#0x00\n"
"} by {\n"
"	sub	a,%1\n"
"	jp	NZ,%2\n"
"	push	%3\n"
"	ld	%4,a\n"
"	; peephole 55 replaced constant #0x00 by a (which has just been tested to be #0x00).\n"
"}\n"
"\n"
"replace restart {\n"
"	dec	a\n"
"	jp	NZ,%1\n"
"	push	%2\n"
"	ld	%3,#0x00\n"
"} by {\n"
"	dec	a\n"
"	jp	NZ,%1\n"
"	push	%2\n"
"	ld	%3,a\n"
"	; peephole 56 replaced constant #0x00 by a (which has just been tested to be #0x00).\n"
"}\n"
"\n"
"replace restart {\n"
"	ld	de,#%1 + %2\n"
"	inc	de\n"
"	inc	de\n"
"	inc	de\n"
"} by {\n"
"	ld	de,#%1 + %2 + 3\n"
"	; peephole 57 moved triple increment of de to constant.\n"
"}\n"
"\n"
"replace restart {\n"
"	ld	de,#%1 + %2\n"
"	inc	de\n"
"	inc	de\n"
"} by {\n"
"	ld	de,#%1 + %2 + 2\n"
"	; peephole 58 moved double increment of de to constant.\n"
"}\n"
"\n"
"replace restart {\n"
"	ld	de,#%1 + %2\n"
"	inc	de\n"
"} by {\n"
"	ld	de,#%1 + %2 + 1\n"
"	; peephole 59 moved increment of de to constant.\n"
"}\n"
"\n"
"replace restart {\n"
"	ld	bc,#%1 + %2\n"
"	inc	bc\n"
"	inc	bc\n"
"	inc	bc\n"
"} by {\n"
"	ld	bc,#%1 + %2 + 3\n"
"	; peephole 60 moved triple increment of bc to constant.\n"
"}\n"
"\n"
"replace restart {\n"
"	ld	bc,#%1 + %2\n"
"	inc	bc\n"
"	inc	bc\n"
"} by {\n"
"	ld	bc,#%1 + %2 + 2\n"
"	; peephole 61 moved double increment of bc to constant.\n"
"}\n"
"\n"
"replace restart {\n"
"	ld	bc,#%1 + %2\n"
"	inc	bc\n"
"} by {\n"
"	ld	bc,#%1 + %2 + 1\n"
"	; peephole 62 moved increment of bc to constant.\n"
"}\n"
"\n"
"replace restart {\n"
"	ld	bc,#%1\n"
"	ld	a,c\n"
"	add	a,#0x%2\n"
"	ld	c,a\n"
"	ld	a,b\n"
"	adc	a,#0x%3\n"
"	ld	b,a\n"
"} by {\n"
"	ld	bc,#%1 + 0x%3%2\n"
"	; peephole 63 moved addition of constant 0x%3%2 to bc to constant.\n"
"}\n"
"\n"
"replace restart {\n"
"	ld	bc,#%1 + %4\n"
"	ld	a,c\n"
"	add	a,#0x%2\n"
"	ld	c,a\n"
"	ld	a,b\n"
"	adc	a,#0x%3\n"
"	ld	b,a\n"
"} by {\n"
"	ld	bc,#%1 + %4 + 0x%3%2\n"
"	; peephole 64 moved addition of constant 0x%3%2 to bc to constant.\n"
"}\n"
"\n"
"replace restart {\n"
"	call	%1\n"
"	ret\n"
"} by {\n"
"	jp	%1\n"
"	; peephole 65 replaced call at end of function by jump.\n"
"}\n"
"\n"
"replace restart {\n"
"	call	%1\n"
"	pop	ix\n"
"	ret\n"
"} by {\n"
"	pop	ix\n"
"	jp	%1\n"
"	; peephole 66 replaced call at end of function by jump moving call beyond pop ix.\n"
"}\n"
"\n"
"\n"
"replace {\n"
"	ld	(hl),a\n"
"	dec	hl\n"
"} by {\n"
"	ld	(hl-),a\n"
"}\n"
"replace {\n"
"	ld	(hl),a\n"
"	inc	hl\n"
"} by {\n"
"	ld	(hl+),a\n"
"}\n"
"replace {\n"
"	ld	a,(hl)\n"
"	inc	hl\n"
"} by {\n"
"	ld	a,(hl+)\n"
"}\n"
"replace {\n"
"	ld	a,[hl]\n"
"	inc	hl\n"
"} by {\n"
"	ld	a,[hl+]\n"
"}\n"
"replace {\n"
"	ld	a,[hl]\n"
"	inc	hl\n"
"} by {\n"
"	ld	a,[hl+]\n"
"}\n"
"replace {\n"
"	ld	[hl],a\n"
"	inc	hl\n"
"} by {\n"
"	ld	[hl+],a\n"
"}\n"
"replace {\n"
"	ld	[hl],a\n"
"	dec	hl\n"
"} by {\n"
"	ld	[hl-],a\n"
"}\n"
"replace {\n"
"	ld	(hl+),a\n"
"	ld	(hl),d\n"
"	dec	hl\n"
"	ld	e,(hl)\n"
"	inc	hl\n"
"	ld	d,(hl)\n"
"	ld	a,(de)\n"
"} by {\n"
"	ld	(hl+),a\n"
"	ld	(hl),d\n"
"	ld	e,a\n"
"	ld	a,(de)\n"
"}\n"
"replace {\n"
"	ld	(hl),a\n"
"	ld	%1,(hl)\n"
"} by {\n"
"	ld	(hl),a\n"
"	ld	%1,a\n"
"}\n"
"replace {\n"
"	ld	(hl),a\n"
"	inc	de\n"
"	ld	a,(de)\n"
"	inc	hl\n"
"} by {\n"
"	ld	(hl+),a\n"
"	inc	de\n"
"	ld	a,(de)\n"
"}\n"
